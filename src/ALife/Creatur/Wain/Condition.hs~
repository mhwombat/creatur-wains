------------------------------------------------------------------------
-- |
-- Module      :  ALife.Creatur.Wain.Condition
-- Copyright   :  (c) Amy de Buitl√©ir 2013
-- License     :  BSD-style
-- Maintainer  :  amy@nualeargais.ie
-- Stability   :  experimental
-- Portability :  portable
--
-- ???
--
------------------------------------------------------------------------
{-# LANGUAGE DeriveGeneric, TypeFamilies #-}
module ALife.Creatur.Wain.Condition
  (
    Condition(..),
    initialCondition,
    randomCondition,
    alive,
    happiness,
    adjustEnergy,
    adjustPassion,
    coolPassion
  ) where

import ALife.Creatur.Genetics.BRGCWord8 (Genetic)
import ALife.Creatur.Genetics.Diploid (Diploid)
import qualified ALife.Creatur.Genetics.BRGCWord8 as G
import qualified ALife.Creatur.Wain.Config as Config
import ALife.Creatur.Wain.Util (unitInterval, enforceRange,
  scaleWord8ToDouble, scaleDoubleToWord8)
import ALife.Creatur.Wain.Statistics (Statistical, stats, dStat)
import Control.Applicative ((<$>), (<*>))
import Control.Monad.Random (Rand, RandomGen, getRandomR)
import Data.Datamining.Pattern (Pattern, Metric, adjustNum,
  difference, makeSimilar)
import Data.Serialize (Serialize)
import GHC.Generics (Generic)

-- | A model of a stimulus and the response to it
data Condition = Condition
  {
    -- | Current energy level
    cEnergy :: Double,
    -- | Current passion level
    cPassion :: Double,
    -- | Current boredom level
    cBoredom :: Double
  } deriving (Eq, Show, Generic)

instance Serialize Condition

-- An agent's current condition is not genetic, of course. However,
-- the initial response patterns stored at birth are genetically
-- determined, and they contain condition information.
instance Genetic Condition where
  put (Condition e p b) = do
    G.put . scaleDoubleToWord8 unitInterval $ e
    G.put . scaleDoubleToWord8 unitInterval $ p
    G.put . scaleDoubleToWord8 unitInterval $ b
  get = do
    e <- fmap (fmap . scaleWord8ToDouble $ unitInterval) G.get
    p <- fmap (fmap . scaleWord8ToDouble $ unitInterval) G.get
    b <- fmap (fmap . scaleWord8ToDouble $ unitInterval) G.get
    return $ Condition <$> e <*> p <*> b

instance Diploid Condition

instance Pattern Condition where
  type Metric Condition = Double
  difference x y
    = sum [eDiff*Config.energyWeight, pDiff*Config.passionWeight,
            bDiff*Config.boredomWeight]
    where eDiff = abs (cEnergy x - cEnergy y)
          pDiff = abs (cPassion x - cPassion y)
          bDiff = abs (cBoredom x - cBoredom y)
  makeSimilar target r x = Condition e p b
    where e = adjustNum (cEnergy target) r (cEnergy x)
          p = adjustNum (cPassion target) r (cPassion x)
          b = adjustNum (cBoredom target) r (cBoredom x)

instance Statistical Condition where
  stats (Condition e p b) =
    [dStat "energy" e, dStat "passion" p, dStat "boredom" b]

-- When agents are created, they have a predetermined initial condition.
-- However, we still need to generate random conditions for use in
-- response patterns.
randomCondition :: RandomGen r => Rand r Condition
randomCondition = Condition <$> getRandomR (0,1) <*>  getRandomR (0,1)
      <*> getRandomR (0,1)

initialCondition :: Condition
initialCondition = Condition 1 0 0

happiness :: Condition -> Double
happiness (Condition e b p)
  = e*Config.energyWeight + (1 - p)*Config.passionWeight
      + (1 - b)*Config.boredomWeight

alive :: Condition -> Bool
alive c = cEnergy c > 0

adjustEnergy :: Double -> Condition -> Condition
adjustEnergy delta c = c {cEnergy=e}
  where e = enforceRange unitInterval (cEnergy c + delta)

adjustPassion :: Double -> Condition -> Condition
adjustPassion delta c = c {cPassion=p}
  where p = enforceRange unitInterval (cPassion c + delta)

coolPassion :: Condition -> Condition
coolPassion c = c {cPassion=0}
