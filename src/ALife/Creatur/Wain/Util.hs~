------------------------------------------------------------------------
-- |
-- Module      :  ALife.Creatur.Wain.Util
-- Copyright   :  (c) Amy de BuitlÃ©ir 2013
-- License     :  BSD-style
-- Maintainer  :  amy@nualeargais.ie
-- Stability   :  experimental
-- Portability :  portable
--
-- Utility functions that don't fit anywhere else.
--
------------------------------------------------------------------------
{-# LANGUAGE DeriveGeneric, TypeFamilies #-}
module ALife.Creatur.Wain.Util
  (
    unitInterval,
    UIDouble,
    uiToDouble,
    doubleToUI,
    UIVector(..),
    uiVectorToDoubles,
    doublesToUIVector,
    enforceRange,
    scaleDoubleToWord8,
    scaleWord8ToDouble,
    scaleIntToWord8,
    scaleWord8ToInt,
    forceIntToWord8,
    word8ToInt,
    forceIntToWord16,
    word16ToInt,
    forceDoubleToWord8,
    word8ToDouble,
  ) where

import qualified ALife.Creatur.Genetics.BRGCWord8 as W8
import ALife.Creatur.Genetics.Diploid (Diploid)
import Data.Datamining.Pattern (Pattern(..), Metric, adjustVector)
import Data.Serialize (Serialize)
import Data.Word (Word8, Word16)
import GHC.Generics (Generic)

unitInterval :: (Double, Double)
unitInterval = (0,1)

-- | A number on the unit interval 0 to 1, inclusive.
newtype UIDouble = UIDouble Double deriving (Show, Eq, Ord, Generic)

uiToDouble :: UIDouble -> Double
uiToDouble (UIDouble x) = x

doubleToUI :: Double -> UIDouble
doubleToUI = UIDouble . enforceRange unitInterval

-- | The initial sequences stored at birth are genetically determined.
instance W8.Genetic UIDouble where
  put = W8.put . scaleDoubleToWord8 unitInterval . uiToDouble
  get = fmap (fmap (UIDouble . scaleWord8ToDouble unitInterval)) W8.get

instance Serialize UIDouble
instance Diploid UIDouble

newtype UIVector = UIVector [UIDouble] deriving (Show, Eq, Generic)

instance Serialize UIVector
instance W8.Genetic UIVector
instance Diploid UIVector

uiVectorToDoubles :: UIVector -> [Double]
uiVectorToDoubles (UIVector xs) = map uiToDouble xs

doublesToUIVector :: [Double] -> UIVector
doublesToUIVector = UIVector . map doubleToUI

instance Pattern UIVector where
  type Metric UIVector = Double
  difference x y =
    if null xs
       then if null ys then 0 else 1
       else d2
    where xs = uiVectorToDoubles x
          ys = uiVectorToDoubles y
          deltas = zipWith (-) xs ys
          d = sum $ map (\z -> z*z) deltas
          d2 = d / (fromIntegral . length $ deltas)
  makeSimilar target r v = doublesToUIVector xs'
    where ts = uiVectorToDoubles target
          xs = uiVectorToDoubles v
          xs' = adjustVector ts r xs

enforceRange :: Ord c => (c, c) -> c -> c
enforceRange (a,b) = max a . min b

-- | @'scaleDoubleToWord8' (a, b) x@ scales @x@ to create a @Word8@ value, such
--   that @scaleDoubleToWord8 (a, b) a@ = 0 and @scaleDoubleToWord8 (a, b) b@ = 255.
scaleDoubleToWord8 :: (Double, Double) -> Double -> Word8
scaleDoubleToWord8 (a, b) x = round (255*(x-a)/(b-a))

-- | This function is the inverse of @'scaleDoubleToWord8'@.
--   @'scaleWord8ToDouble' (a, b) 0@ = a and @'scaleWord8ToDouble' (a, b) 255@ = b.
scaleWord8ToDouble :: (Double, Double) -> Word8 -> Double
scaleWord8ToDouble (a, b) x = a + (fromIntegral x)*(b-a)/255

-- | @'scaleIntToWord8' (a, b) x@ scales @x@ to create a @Word8@ value, such
--   that @scaleIntToWord8 (a, b) a@ = 0 and @scaleIntToWord8 (a, b) b@ = 255.
scaleIntToWord8 :: (Int, Int) -> Int -> Word8
scaleIntToWord8 (a, b) x = round (255*(x'-a')/(b'-a'))
  where a' = fromIntegral a :: Double
        b' = fromIntegral b :: Double
        x' = fromIntegral x :: Double

-- | This function is the inverse of @'scaleIntToWord8'@.
--   @'scaleWord8ToInt' (a, b) 0@ = a and @'scaleWord8ToInt' (a, b) 255@ = b.
scaleWord8ToInt :: (Int, Int) -> Word8 -> Int
scaleWord8ToInt (a, b) x = a + (fromIntegral x)*(b-a) `div` 255

forceIntToWord8 :: Int -> Word8
forceIntToWord8 = fromIntegral . min maxBound

word8ToInt :: Word8 -> Int
word8ToInt = fromIntegral

forceIntToWord16 :: Int -> Word16
forceIntToWord16 = fromIntegral . min maxBound

word16ToInt :: Word16 -> Int
word16ToInt = fromIntegral

forceDoubleToWord8 :: Double -> Word8
forceDoubleToWord8 = round . min 255

word8ToDouble :: Word8 -> Double
word8ToDouble = fromIntegral
