------------------------------------------------------------------------
-- |
-- Module      :  ALife.Creatur.Wain.TestUtils
-- Copyright   :  (c) Amy de Buitl√©ir 2013
-- License     :  BSD-style
-- Maintainer  :  amy@nualeargais.ie
-- Stability   :  experimental
-- Portability :  portable
--
-- QuickCheck test utilities.
--
------------------------------------------------------------------------
{-# LANGUAGE DeriveGeneric, TypeFamilies, FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
module ALife.Creatur.Wain.TestUtils
  (
    TestPattern,
    Float8,
    doubleToFloat8,
    Inexact(..),
    arb8BitDouble,
    arb8BitInt,
    prop_serialize_round_trippable,
    prop_genetic_round_trippable,
    prop_diploid_identity,
    prop_show_read_round_trippable,
    test
  ) where

import qualified ALife.Creatur.Genetics.BRGCWord8 as W8
import ALife.Creatur.Genetics.Diploid (Diploid, express)
import ALife.Creatur.Util (fromEither)
import ALife.Creatur.Wain.Util (scaleFromWord8, scaleToWord8,
  scaleWord8ToInt, forceToWord8, enforceRange)
import Control.Applicative ((<$>))
import Data.Datamining.Pattern (Pattern(..), Metric, adjustNum)
import Data.Serialize (Serialize, encode, decode)
import Data.Word (Word8)
import GHC.Generics (Generic)
import System.Random (Random, random, randomR)
import Test.Framework (Test, testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.QuickCheck

-- instance (Floating a, Fractional a, Ord a, Eq a) => Pattern [a] where
--   type Metric [a] = a
--   difference = euclideanDistanceSquared
--   makeSimilar = adjustVector

arb8BitDouble :: (Double, Double) -> Gen Double
arb8BitDouble interval = do 
  x <- arbitrary :: Gen Word8
  return $ scaleFromWord8 interval x
  
arb8BitInt :: (Int, Int) -> Gen Int
arb8BitInt interval = do 
  x <- arbitrary :: Gen Word8
  return $ scaleWord8ToInt interval x
  
prop_serialize_round_trippable :: (Eq a, Serialize a) => a -> Property
prop_serialize_round_trippable x = property $ x' == Right x
  where bs = encode x
        x' = decode bs

prop_genetic_round_trippable :: (Eq g, W8.Genetic g, Show g) =>
  (g -> g -> Bool) -> g -> Property
prop_genetic_round_trippable eq g = property $ g' `eq` g
  where x = W8.write g
        g' = fromEither (error "read returned Nothing") . W8.read $ x

prop_diploid_identity :: Diploid g => (g -> g -> Bool) -> g -> Property
prop_diploid_identity eq g = property $ express g g `eq` g

prop_show_read_round_trippable :: (Read a, Show a) => (a -> a -> Bool) -> a -> Property
prop_show_read_round_trippable eq x
  = property $ (read . show $ x) `eq` x
    
data TestPattern = TestPattern Word8
  deriving (Show, Eq, Generic)

instance Serialize TestPattern
instance W8.Genetic TestPattern
instance Diploid TestPattern

instance Arbitrary TestPattern where
  arbitrary = TestPattern <$> arbitrary

instance Pattern TestPattern where
  type Metric TestPattern = Float8
  difference (TestPattern x) (TestPattern y)
    = abs (fromIntegral x - fromIntegral y) / 255
  makeSimilar (TestPattern target) r (TestPattern x)
    = TestPattern (forceToWord8 x'')
    where t' = fromIntegral target :: Float8
          x' = fromIntegral x :: Float8
          x'' = adjustNum t' r x'

-- | A number on the unit interval 0 to 1, inclusive.
newtype Float8 = Float8 Double
  deriving (Eq, Ord, Generic)

instance Show Float8 where
  show (Float8 a) = "doubleToFloat8 " ++ show a

instance Serialize Float8
instance Diploid Float8

float8Interval :: Num a => (a,a)
float8Interval = (-127,127)

doubleToFloat8 :: Double -> Float8
doubleToFloat8 = Float8 . enforceRange float8Interval

instance Real Float8 where
  toRational (Float8 a) = toRational a

instance Num Float8 where
  (Float8 a) + (Float8 b) = doubleToFloat8 (a + b)
  (Float8 a) - (Float8 b) = doubleToFloat8 (a - b)
  (Float8 a) * (Float8 b) = doubleToFloat8 (a * b)
  abs (Float8 a) = doubleToFloat8 . abs $ a
  signum (Float8 a) = doubleToFloat8 . signum $ a
  fromInteger = doubleToFloat8 . fromInteger

instance Fractional Float8 where
  -- If 0 <= a <= 1, then 1/a >= 1. Restricting that to the unit
  -- interval gives 1.
  recip (Float8 _) = 1
  fromRational = Float8 . enforceRange float8Interval . fromRational

instance RealFrac Float8 where
  properFraction (Float8 a) = (n, doubleToFloat8 f)
    where (n, f) = properFraction a

instance W8.Genetic Float8 where
  put (Float8 a) = W8.put . scaleToWord8 float8Interval $ a
  get = do
    a <- W8.get
    return . fmap (doubleToFloat8 . scaleFromWord8 float8Interval) $ a

instance Pattern Float8 where
  type Metric Float8 = Float8
  difference a b = abs $ (-) a b
  makeSimilar = adjustNum

instance Arbitrary Float8 where
  arbitrary = doubleToFloat8 <$> arb8BitDouble float8Interval

instance Floating Float8 where
  pi = doubleToFloat8 pi
  exp (Float8 a) = doubleToFloat8 . exp $ a
  log (Float8 a) = doubleToFloat8 . log $ a
  sin (Float8 a) = doubleToFloat8 . sin $ a
  cos (Float8 a) = doubleToFloat8 . cos $ a
  sinh (Float8 a) = doubleToFloat8 . sinh $ a
  cosh (Float8 a) = doubleToFloat8 . cosh $ a
  asin (Float8 a) = doubleToFloat8 . asin $ a
  acos (Float8 a) = doubleToFloat8 . acos $ a
  atan (Float8 a) = doubleToFloat8 . atan $ a
  asinh (Float8 a) = doubleToFloat8 . asinh $ a
  acosh (Float8 a) = doubleToFloat8 . acosh $ a
  atanh (Float8 a) = doubleToFloat8 . atanh $ a

instance Random Float8 where
  randomR ((Float8 lo), (Float8 hi)) g = (doubleToFloat8 a, g')
    where (a, g') = randomR (lo, hi) g
  random = randomR (0, 1)

class Inexact a where
  equiv :: a -> a -> Bool

-- instance Inexact Float8 where
--   equiv x y = abs (x - y) < 0.01

test :: Test
test = testGroup "ALife.Creatur.Wain.TestUtils"
  [
    testProperty "prop_serialize_round_trippable - Response"
      (prop_serialize_round_trippable :: Float8 -> Property),
    testProperty "prop_genetic_round_trippable - Response"
      (prop_genetic_round_trippable (==) :: Float8 -> Property),
    testProperty "prop_diploid_identity - Response"
      (prop_diploid_identity (==) :: Float8 -> Property)
  ]
